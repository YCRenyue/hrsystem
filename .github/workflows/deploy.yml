name: ðŸš€ Deploy to Aliyun ECS

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      deploy_backend:
        description: 'ðŸ–¥ï¸ éƒ¨ç½²åŽç«¯æœåŠ¡'
        required: false
        type: boolean
        default: false
      deploy_frontend:
        description: 'ðŸŒ éƒ¨ç½²å‰ç«¯æœåŠ¡'
        required: false
        type: boolean
        default: false
      deploy_all:
        description: 'ðŸš€ éƒ¨ç½²æ‰€æœ‰æœåŠ¡ (ä¼˜å…ˆçº§æœ€é«˜)'
        required: false
        type: boolean
        default: true
      skip_cache:
        description: 'âŒ è·³è¿‡æž„å»ºç¼“å­˜'
        required: false
        type: boolean
        default: false

env:
  # Aliyun ACR Configuration
  ACR_REGISTRY: crpi-1f9h7rkbm8zj38tu.cn-zhangjiakou.personal.cr.aliyuncs.com
  ACR_REGISTRY_VPC: crpi-1f9h7rkbm8zj38tu-vpc.cn-zhangjiakou.personal.cr.aliyuncs.com
  ACR_NAMESPACE: ycrenyue
  ACR_REPOSITORY_BACKEND: hrsystem-backend
  ACR_REPOSITORY_FRONTEND: hrsystem-frontend
  BACKEND_PORT: 3001
  FRONTEND_PORT: 80

jobs:
  # 1. æ£€æµ‹å˜æ›´å’Œé…ç½®
  prepare:
    name: ðŸ“‹ å‡†å¤‡å’Œæ£€æµ‹
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      should_deploy_backend: ${{ steps.deployment_logic.outputs.should_deploy_backend }}
      should_deploy_frontend: ${{ steps.deployment_logic.outputs.should_deploy_frontend }}
      use_cache: ${{ steps.deployment_logic.outputs.use_cache }}
      image_tag: ${{ steps.deployment_logic.outputs.image_tag }}
    steps:
      - name: ðŸ”„ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” æ£€æµ‹æ–‡ä»¶å˜æ›´
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'backend/Dockerfile'
            frontend:
              - 'frontend/**'
              - 'frontend/Dockerfile'
            shared:
              - '**/package.json'
              - '.github/workflows/deploy.yml'

      - name: ðŸ§  éƒ¨ç½²é€»è¾‘å†³ç­–
        id: deployment_logic
        run: |
          MANUAL_BACKEND="${{ github.event.inputs.deploy_backend }}"
          MANUAL_FRONTEND="${{ github.event.inputs.deploy_frontend }}"
          MANUAL_ALL="${{ github.event.inputs.deploy_all }}"
          SKIP_CACHE="${{ github.event.inputs.skip_cache }}"

          CHANGED_BACKEND="${{ steps.filter.outputs.backend }}"
          CHANGED_FRONTEND="${{ steps.filter.outputs.frontend }}"
          CHANGED_SHARED="${{ steps.filter.outputs.shared }}"

          # ä¼˜å…ˆçº§ï¼šæ‰‹åŠ¨éƒ¨ç½²æ‰€æœ‰ > æ‰‹åŠ¨æŒ‡å®š > è‡ªåŠ¨æ£€æµ‹
          if [[ "$MANUAL_ALL" == "true" ]]; then
            echo "should_deploy_backend=true" >> $GITHUB_OUTPUT
            echo "should_deploy_frontend=true" >> $GITHUB_OUTPUT
          elif [[ "$MANUAL_BACKEND" == "true" ]] || [[ "$MANUAL_FRONTEND" == "true" ]]; then
            echo "should_deploy_backend=$MANUAL_BACKEND" >> $GITHUB_OUTPUT
            echo "should_deploy_frontend=$MANUAL_FRONTEND" >> $GITHUB_OUTPUT
          else
            # å…±äº«é…ç½®å˜æ›´æ—¶åŒæ—¶éƒ¨ç½²å‰åŽç«¯
            if [[ "$CHANGED_SHARED" == "true" ]]; then
              echo "should_deploy_backend=true" >> $GITHUB_OUTPUT
              echo "should_deploy_frontend=true" >> $GITHUB_OUTPUT
            else
              echo "should_deploy_backend=$CHANGED_BACKEND" >> $GITHUB_OUTPUT
              echo "should_deploy_frontend=$CHANGED_FRONTEND" >> $GITHUB_OUTPUT
            fi
          fi

          echo "use_cache=true" >> $GITHUB_OUTPUT
          if [[ "$SKIP_CACHE" == "true" ]]; then
            echo "use_cache=false" >> $GITHUB_OUTPUT
          fi

          IMAGE_TAG=$(git rev-parse --short HEAD)
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: ðŸ“Š çŽ¯å¢ƒä¿¡æ¯å±•ç¤º
        run: |
          echo "ðŸ”§ éƒ¨ç½²å†³ç­–ç»“æžœ:"
          echo "  - éƒ¨ç½²åŽç«¯: ${{ steps.deployment_logic.outputs.should_deploy_backend }}"
          echo "  - éƒ¨ç½²å‰ç«¯: ${{ steps.deployment_logic.outputs.should_deploy_frontend }}"
          echo "  - ä½¿ç”¨ç¼“å­˜: ${{ steps.deployment_logic.outputs.use_cache }}"
          echo "  - é•œåƒæ ‡ç­¾: ${{ steps.deployment_logic.outputs.image_tag }}"

  # 2. æž„å»ºå’ŒæŽ¨é€é•œåƒ
  build-and-push:
    name: ðŸ—ï¸ æž„å»ºå’ŒæŽ¨é€é•œåƒ
    runs-on: ubuntu-latest
    needs: prepare
    if: ${{ needs.prepare.outputs.should_deploy_backend == 'true' || needs.prepare.outputs.should_deploy_frontend == 'true' }}
    permissions:
      contents: read
      packages: write
    outputs:
      backend_image: ${{ steps.image_info.outputs.backend_image }}
      frontend_image: ${{ steps.image_info.outputs.frontend_image }}

    steps:
      - name: ðŸ”„ Checkout repository
        uses: actions/checkout@v4

      - name: âš™ï¸ è®¾ç½® Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” ç™»å½• ACR
        run: |
          echo "${{ secrets.ACR_PASSWORD }}" | docker login \
            --username "${{ secrets.ACR_USERNAME }}" \
            --password-stdin \
            "${{ env.ACR_REGISTRY }}"

      # æž„å»ºå’ŒæŽ¨é€åŽç«¯é•œåƒ
      - name: ðŸ—ï¸ æž„å»ºå’ŒæŽ¨é€åŽç«¯é•œåƒ
        if: ${{ needs.prepare.outputs.should_deploy_backend == 'true' }}
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
        run: |
          cd backend

          FULL_IMAGE="${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/${{ env.ACR_REPOSITORY_BACKEND }}:${IMAGE_TAG}"
          LATEST_IMAGE="${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/${{ env.ACR_REPOSITORY_BACKEND }}:latest"

          if [[ "${{ needs.prepare.outputs.use_cache }}" == "true" ]]; then
            docker buildx build \
              --platform linux/amd64 \
              --cache-from type=registry,ref=${LATEST_IMAGE} \
              --cache-to type=inline \
              --tag ${FULL_IMAGE} \
              --tag ${LATEST_IMAGE} \
              --push . || {
              echo "âš ï¸ Buildx å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿæž„å»º"
              docker build --tag ${FULL_IMAGE} --tag ${LATEST_IMAGE} .
              docker push ${FULL_IMAGE}
              docker push ${LATEST_IMAGE}
            }
          else
            docker build --tag ${FULL_IMAGE} --tag ${LATEST_IMAGE} .
            docker push ${FULL_IMAGE}
            docker push ${LATEST_IMAGE}
          fi

          echo "âœ… Backend image pushed: ${FULL_IMAGE}"

      # æž„å»ºå’ŒæŽ¨é€å‰ç«¯é•œåƒ
      - name: ðŸŒ æž„å»ºå’ŒæŽ¨é€å‰ç«¯é•œåƒ
        if: ${{ needs.prepare.outputs.should_deploy_frontend == 'true' }}
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
          REACT_APP_API_URL: ${{ secrets.BACKEND_API_URL }}
        run: |
          cd frontend

          FULL_IMAGE="${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/${{ env.ACR_REPOSITORY_FRONTEND }}:${IMAGE_TAG}"
          LATEST_IMAGE="${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/${{ env.ACR_REPOSITORY_FRONTEND }}:latest"

          if [[ "${{ needs.prepare.outputs.use_cache }}" == "true" ]]; then
            docker buildx build \
              --platform linux/amd64 \
              --build-arg REACT_APP_API_URL=${REACT_APP_API_URL} \
              --cache-from type=registry,ref=${LATEST_IMAGE} \
              --cache-to type=inline \
              --tag ${FULL_IMAGE} \
              --tag ${LATEST_IMAGE} \
              --push . || {
              echo "âš ï¸ Buildx å¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿæž„å»º"
              docker build \
                --build-arg REACT_APP_API_URL=${REACT_APP_API_URL} \
                --tag ${FULL_IMAGE} \
                --tag ${LATEST_IMAGE} .
              docker push ${FULL_IMAGE}
              docker push ${LATEST_IMAGE}
            }
          else
            docker build \
              --build-arg REACT_APP_API_URL=${REACT_APP_API_URL} \
              --tag ${FULL_IMAGE} \
              --tag ${LATEST_IMAGE} .
            docker push ${FULL_IMAGE}
            docker push ${LATEST_IMAGE}
          fi

          echo "âœ… Frontend image pushed: ${FULL_IMAGE}"

      - name: ðŸ“ è¾“å‡ºé•œåƒä¿¡æ¯
        id: image_info
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
        run: |
          if [[ "${{ needs.prepare.outputs.should_deploy_backend }}" == "true" ]]; then
            # Use VPC registry for ECS deployment (internal network)
            BACKEND_IMAGE="${{ env.ACR_REGISTRY_VPC }}/${{ env.ACR_NAMESPACE }}/${{ env.ACR_REPOSITORY_BACKEND }}:${IMAGE_TAG}"
            echo "backend_image=${BACKEND_IMAGE}" >> $GITHUB_OUTPUT
          fi

          if [[ "${{ needs.prepare.outputs.should_deploy_frontend }}" == "true" ]]; then
            # Use VPC registry for ECS deployment (internal network)
            FRONTEND_IMAGE="${{ env.ACR_REGISTRY_VPC }}/${{ env.ACR_NAMESPACE }}/${{ env.ACR_REPOSITORY_FRONTEND }}:${IMAGE_TAG}"
            echo "frontend_image=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT
          fi

  # 3. éƒ¨ç½²åˆ° ECS (å‰åŽç«¯åœ¨åŒä¸€å®žä¾‹ï¼Œé€šè¿‡ NAT ç½‘å…³ DNAT è®¿é—®)
  deploy-to-ecs:
    name: ðŸš€ éƒ¨ç½²åˆ° ECS
    runs-on: ubuntu-latest
    needs: [prepare, build-and-push]
    if: ${{ needs.build-and-push.result == 'success' }}

    steps:
      - name: ðŸ”„ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ” é…ç½® SSH å¯†é’¥
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.ECS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # é€šè¿‡ NAT ç½‘å…³çš„è‡ªå®šä¹‰ç«¯å£æ‰«æ SSH host key
          ssh-keyscan -p ${{ secrets.ECS_SSH_PORT }} -H ${{ secrets.ECS_NAT_IP }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: ðŸš€ éƒ¨ç½²æœåŠ¡åˆ° ECS
        env:
          IMAGE_TAG: ${{ needs.prepare.outputs.image_tag }}
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
          DEPLOY_BACKEND: ${{ needs.prepare.outputs.should_deploy_backend }}
          DEPLOY_FRONTEND: ${{ needs.prepare.outputs.should_deploy_frontend }}
          FRONTEND_URL: ${{ vars.FRONTEND_URL }}
        run: |
          # SSH é€šè¿‡ NAT ç½‘å…³è¿žæŽ¥ (NAT_IP:SSH_PORT -> ECS:22)
          NAT_IP="${{ secrets.ECS_NAT_IP }}"
          SSH_PORT="${{ secrets.ECS_SSH_PORT }}"

          echo "ðŸ”— é€šè¿‡ NAT ç½‘å…³è¿žæŽ¥ ECS: ${NAT_IP}:${SSH_PORT}"

          ssh -o StrictHostKeyChecking=no -p ${SSH_PORT} root@${NAT_IP} << ENDSSH
            set -e
            set -x

            echo "ðŸ“¦ ç™»å½•é˜¿é‡Œäº‘ ACR..."
            echo "${{ secrets.ACR_PASSWORD }}" | docker login \
              --username "${{ secrets.ACR_USERNAME }}" \
              --password-stdin \
              "${{ env.ACR_REGISTRY_VPC }}"

            # éƒ¨ç½²åŽç«¯
            if [[ "${DEPLOY_BACKEND}" == "true" ]]; then
              echo "ðŸ–¥ï¸ éƒ¨ç½²åŽç«¯æœåŠ¡..."

              docker pull ${BACKEND_IMAGE}

              docker stop hrsystem-backend 2>/dev/null || true
              docker rm hrsystem-backend 2>/dev/null || true

              # èŽ·å– MySQL å®¹å™¨æ‰€åœ¨çš„ç½‘ç»œ (å°è¯• hrsystem-db æˆ– root-db-1)
              MYSQL_NETWORK=$(docker inspect hrsystem-db --format '{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}' 2>/dev/null || \
                             docker inspect root-db-1 --format '{{range $k, $v := .NetworkSettings.Networks}}{{$k}}{{end}}' 2>/dev/null || echo "")

              # å¦‚æžœæ²¡æœ‰æ£€æµ‹åˆ°ç½‘ç»œï¼Œä½¿ç”¨é»˜è®¤çš„ hrsystem-network
              if [ -z "$MYSQL_NETWORK" ]; then
                MYSQL_NETWORK="hrsystem-network"
                # ç¡®ä¿ç½‘ç»œå­˜åœ¨
                docker network create $MYSQL_NETWORK 2>/dev/null || true
              fi

              echo "ä½¿ç”¨ç½‘ç»œ: $MYSQL_NETWORK"
              NETWORK_PARAM="--network $MYSQL_NETWORK"

              docker run -d \
                --name hrsystem-backend \
                --restart unless-stopped \
                $NETWORK_PARAM \
                -p ${{ env.BACKEND_PORT }}:3001 \
                -e NODE_ENV=production \
                -e PORT=3001 \
                -e FRONTEND_URL=$FRONTEND_URL \
                -e DB_HOST=${{ vars.DB_HOST }} \
                -e DB_PORT=${{ vars.DB_PORT }} \
                -e DB_NAME=${{ vars.DB_NAME }} \
                -e DB_USER=${{ vars.DB_USER }} \
                -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
                -e DB_TIMEZONE=${{ vars.DB_TIMEZONE }} \
                -e JWT_SECRET=${{ secrets.JWT_SECRET }} \
                -e ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }} \
                ${BACKEND_IMAGE}

              echo "â³ ç­‰å¾…åŽç«¯æœåŠ¡å¯åŠ¨..."
              sleep 10
              if curl -sf http://localhost:${{ env.BACKEND_PORT }}/health > /dev/null; then
                echo "âœ… åŽç«¯æœåŠ¡éƒ¨ç½²æˆåŠŸ"
              else
                echo "âš ï¸ åŽç«¯å¥åº·æ£€æŸ¥å¤±è´¥ï¼ŒæŸ¥çœ‹æ—¥å¿—ï¼š"
                docker logs hrsystem-backend --tail 30
              fi
            fi

            # éƒ¨ç½²å‰ç«¯
            if [[ "${DEPLOY_FRONTEND}" == "true" ]]; then
              echo "ðŸŒ éƒ¨ç½²å‰ç«¯æœåŠ¡..."

              docker pull ${FRONTEND_IMAGE}

              # åœæ­¢æ‰€æœ‰å¯èƒ½å ç”¨ç«¯å£çš„å®¹å™¨
              docker stop hrsystem-frontend 2>/dev/null || true
              docker rm hrsystem-frontend 2>/dev/null || true

              # æŸ¥æ‰¾å¹¶åœæ­¢å ç”¨ 80 ç«¯å£çš„å®¹å™¨
              CONTAINER_ON_PORT=$(docker ps -q --filter "publish=${{ env.FRONTEND_PORT }}")
              if [ -n "$CONTAINER_ON_PORT" ]; then
                echo "å‘çŽ°å ç”¨ç«¯å£ ${{ env.FRONTEND_PORT }} çš„å®¹å™¨ï¼Œæ­£åœ¨åœæ­¢..."
                docker stop $CONTAINER_ON_PORT 2>/dev/null || true
                docker rm $CONTAINER_ON_PORT 2>/dev/null || true
              fi

              docker run -d \
                --name hrsystem-frontend \
                --restart unless-stopped \
                -p ${{ env.FRONTEND_PORT }}:80 \
                ${FRONTEND_IMAGE}

              echo "â³ ç­‰å¾…å‰ç«¯æœåŠ¡å¯åŠ¨..."
              sleep 5
              if curl -sf http://localhost:${{ env.FRONTEND_PORT }}/ > /dev/null; then
                echo "âœ… å‰ç«¯æœåŠ¡éƒ¨ç½²æˆåŠŸ"
              else
                echo "âš ï¸ å‰ç«¯å¥åº·æ£€æŸ¥å¤±è´¥ï¼ŒæŸ¥çœ‹æ—¥å¿—ï¼š"
                docker logs hrsystem-frontend --tail 30
              fi
            fi

            # æ¸…ç†æ—§é•œåƒ
            echo "ðŸ§¹ æ¸…ç†æ—§é•œåƒ..."
            docker image prune -af --filter "until=24h" || true

            echo "ðŸ“Š å½“å‰è¿è¡Œçš„å®¹å™¨ï¼š"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          ENDSSH

          if [ $? -eq 0 ]; then
            echo "ðŸŽ‰ éƒ¨ç½²å®Œæˆ"
          else
            echo "âŒ éƒ¨ç½²å¤±è´¥"
            exit 1
          fi

      - name: ðŸ“Š ç”Ÿæˆéƒ¨ç½²æ‘˜è¦
        if: always()
        run: |
          mkdir -p deployment-manifests

          cat > deployment-manifests/deployment-summary.md << EOF
          # ðŸš€ éƒ¨ç½²æˆåŠŸæ‘˜è¦

          **éƒ¨ç½²æ—¶é—´**: $(date)
          **è§¦å‘æ–¹å¼**: ${{ github.event_name }}
          **æäº¤å“ˆå¸Œ**: ${{ github.sha }}
          **é•œåƒæ ‡ç­¾**: ${{ needs.prepare.outputs.image_tag }}

          ## ðŸ“‹ æœåŠ¡éƒ¨ç½²æƒ…å†µ

          | æœåŠ¡ | çŠ¶æ€ | é•œåƒåœ°å€ |
          |------|------|----------|
          | åŽç«¯æœåŠ¡ | ${{ needs.prepare.outputs.should_deploy_backend == 'true' && 'ðŸŸ¢ å·²éƒ¨ç½²' || 'â­• æœªéƒ¨ç½²' }} | ${{ needs.build-and-push.outputs.backend_image || 'N/A' }} |
          | å‰ç«¯æœåŠ¡ | ${{ needs.prepare.outputs.should_deploy_frontend == 'true' && 'ðŸŸ¢ å·²éƒ¨ç½²' || 'â­• æœªéƒ¨ç½²' }} | ${{ needs.build-and-push.outputs.frontend_image || 'N/A' }} |

          ## ðŸ”§ çŽ¯å¢ƒä¿¡æ¯

          - **ACR æ³¨å†Œè¡¨**: \`${{ env.ACR_REGISTRY }}\`
          - **ACR VPC åœ°å€**: \`${{ env.ACR_REGISTRY_VPC }}\`
          - **å‘½åç©ºé—´**: \`${{ env.ACR_NAMESPACE }}\`
          - **åŽç«¯ç«¯å£**: \`${{ env.BACKEND_PORT }}\`
          - **å‰ç«¯ç«¯å£**: \`${{ env.FRONTEND_PORT }}\`

          ## ðŸ“ˆ ä¸‹ä¸€æ­¥æ“ä½œ

          1. éªŒè¯æœåŠ¡å¥åº·çŠ¶æ€
          2. æ£€æŸ¥åº”ç”¨æ—¥å¿—
          3. è¿è¡Œå†’çƒŸæµ‹è¯•
          4. æµ‹è¯•å‰åŽç«¯è¿žæŽ¥

          ## ðŸ”— æ•°æ®åº“é…ç½®

          - **DB_HOST**: \`${{ vars.DB_HOST }}\`
          - **DB_NAME**: \`${{ vars.DB_NAME }}\`

          ---
          *Generated by GitHub Actions - Run #${{ github.run_number }}*
          EOF

          cat deployment-manifests/deployment-summary.md

      - name: ðŸ“¦ å½’æ¡£éƒ¨ç½²æ‘˜è¦
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary-${{ github.run_number }}
          path: deployment-manifests/
          retention-days: 30

      - name: ðŸŽ¯ æ˜¾ç¤ºæœ€ç»ˆç»“æžœ
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "ðŸŽ‰ éƒ¨ç½²æˆåŠŸå®Œæˆ!"
            echo "âœ… åŽç«¯éƒ¨ç½²: ${{ needs.prepare.outputs.should_deploy_backend }}"
            echo "âœ… å‰ç«¯éƒ¨ç½²: ${{ needs.prepare.outputs.should_deploy_frontend }}"
          else
            echo "âŒ éƒ¨ç½²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ—¥å¿—"
            exit 1
          fi
